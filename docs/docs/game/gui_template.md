# Макет GUI контексту

Після створення каркаса модуля до нього, за потреби, можна додати шаблон GUI. Це не обов’язкова умова. Модуль може працювати і без нього. Проте в нашому випадку GUI необхідний. 

### Ідентифікатори віджетів

Перш ніж починати створювати віджети та наповнювати шаблон, дуже рекомендується створити перечислення, яке міститиме ідентифікатори віджетів. Це необхідно для того, щоб кожен віджет мав унікальний ідентифікатор. Контейнер віджетів прийме вказівник на віджет тільки з унікальним ідентифікатором для цього контейнера. Я завжди даю назву типу цього перечислення *WidgetID*. 

!!! warning "Важливо"
    Ідентифікатор віджета повинен бути більшим за 0. Через це перечислення з починається саме з 1. 

Хоча конструктор віджета може приймати в якості ідентифікатора двобайтове число, потреба в цьому виникає дуже рідко. Зазвичай, вистачає одного байта. Тому тип перечислення обрано як *uint8_t*.

Вигода від такого підходу з перечисленням полягає в тому, що не потрібно самостійно слідкувати за унікальністю ідентифікаторів. Достатньо лише вказати його ім’я.

Створення шаблону головного меню гри відбувається у методі з ім’ям *showMainMenuTemplate*. Загалом, код в методі достатньо закоментований. Усі методи віджетів також мають документацію. Тому, проблем з розумінням коду у вас не повинно виникнути. 

Щодо методу *showMainMenuTemplate* потрібно відмітити наступні неявні особливості:

* Змінювати UI-шаблон для контексту, можна скільки завгодно разів. В тому числі через зворотні виклики. 
* Створювати пункти меню не обов’язково вручну. Особливо, якщо їх доволі багато. Можна налаштувати створення віджетів в циклі, а інформацію для них брати, наприклад, з масивів.
* Віджети Meowui не підтримують напряму спецефекти на зразок градієнту, глянцевого блиску, прозорості, тощо. Проте, текстові мітки підтримують відображення фонових зображень. Завдяки цьому, можна побудувати меню, пункти якого матимуть сучасний вигляд.

В даному прикладі, використовується два фонових зображення. Не судіть суворо за їх якість виконання :) Одне застосовується до елемента меню, коли він не у фокусі, а інше додається, коли елемент потрапляє у фокус. Під час створення шаблону 0-вий елемент списку завжди отримує фонове зображення "у фокусі". Під час натискання кнопок відбувається зміна фону у методах *setItemBackNormal* та *setItemBackHover*. Методи надзвичайно прості. Перший - дістає з меню вказівник на поточний обраний елемент меню, та замінює йому фон на "звичайний", а другий робить те саме, тільки замінює фон на "у фокусі".

!!! warning "Важливо"
    Текстова мітка не видаляє віджет свого  фонового зображення з пам’яті. Це зроблено для економії ресурсів МК, щоб одне і те ж зображення можна було перевикористовувати для різних пунктів меню. Тому в деструкторі контексту або в іншому підходящому місці необхідно обо’вязково вручну викликати видалення таких віджетів.

### Кешування вказівників на віджети шаблону 
Meowui проектувалася, в першу чергу, для високої продуктивності. Тому у користувача є вибір, кешувати вказівник на віджет або діставати його за потреби з контейнера. 

Перший варіант працює наступним чином: під час створення віджета для шаблону, вказівник на нього додається не тільки в шаблон, а також і в поле класу контекста. В процесі роботи програми можна звернутися до цього вказівника і напряму змінити параметри віджета. З точки зору продуктивності, це завжди дуже швидко, незалежно від кількості віджетів в контейнері. Але цей підхід має один суттєвий недолік - потрібно самостійно контролювати стан контексту. Якщо віджет вже був видалений разом з шаблоном, то при спробі звернутися до нього через невалідний вказівник отримаємо перезавантаження прошивки. Тож від розробника вимагається підвищена уважність.

Другий варіант пропонує діставати вказівник на віджет з контейнера по його ідентифікатору. Цей спосіб завжди повертає валідний вказівник або nullptr, але у разі необхідності постійної зміни віджета, він буде менш ефективним щодо використання ресурсів МК. Особливо, якщо віджетів в контейнері багато.

Я обираю завжди перший варіант. Ви можете обрати для себе той варіант, який вам більше до вподоби. 

### Стан контексту

Стан контексту, це абстрактне поняття, яке не стосується архітектури Meowui. Фактично, це механізм, що реалізується розробником на основі перечислення, який буде допомагати однозначно визначати місце поточного перебування користувача в межах контексту. 

Для прикладу маємо контекст(модуль) файлового менеджера. Головне його вікно, це перший стан. Відкрите контекстне меню файла, це другий стан. Діалогове вікно зміни імені файла - третій стан. В кожному із станів потрібно обробляти кнопки чи що-завгодно інше по-різному. Тож, перевіряючи лише одну змінну, яка містить значення перелічення станів контекста, можна легко і однозначно визначити, який обробник кнопок потрібно використовувати в кожен момент часу.

Для контролю стану контексту я додав перечислення StateID та змінну, яка зберігає одне зі значень цього перечислення. Коли створюється новий шаблон UI в межах одного і того ж контексту, в змінну встановлюється відповідний ідентифікатор стану. 
!!! note "Рекомендація"
    Використовуйте стани контексту тільки там, де без цього дійсно не обійтися. Якщо є можливість, завжди розділяйте один великий контекст на декілька менших. Це значно спростить розробку через зменшення коду в межах одного контексту.